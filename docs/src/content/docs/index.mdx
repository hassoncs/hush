---
title: Hush
description: The AI-native secrets manager. Secrets stay encrypted at rest—AI helps without seeing values.
template: splash
hero:
  title: The AI-native secrets manager
  tagline: Secrets stay encrypted at rest. AI helps—without ever seeing values. Works with every framework.
  image:
    html: '<img src="/images/hero.png" alt="Bioluminescent jellyfish representing AI-native secrets management" style="width: 100%; height: auto; border-radius: 8px; display: block; margin: 0 auto;">'
  actions:
    - text: Get Started
      link: /getting-started/
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/hassoncs/hush
      icon: external
      variant: minimal
---

import { Card, CardGrid, Code, Tabs, TabItem } from '@astrojs/starlight/components';

## Install in Seconds

<Tabs>
  <TabItem label="With AI Assistant">
    Install the Claude Code / OpenCode skill, then let AI handle the rest:
    <Code code="npx @chriscode/hush skill" lang="bash" />
    Once installed, just ask your AI: *"Set up Hush for this project"*
  </TabItem>
  <TabItem label="Manual Setup">
    <Code code={`# Install Hush
npm install -D @chriscode/hush

# Initialize config
npx hush init

# Encrypt your secrets
npx hush encrypt`} lang="bash" />
  </TabItem>
</Tabs>

## Why Hush?

Is Hush just a wrapper around [SOPS](https://github.com/getsops/sops) and [dotenv](https://github.com/motdotla/dotenv)?

**Yes, and that's the point.**

Hush is an **orchestration layer** that solves the "Human + AI" workflow problem that raw tools ignore:

<CardGrid stagger>
  <Card title="Orchestration" icon="random">
    `sops exec` handles one file. Hush merges multiple sources (`shared` + `env` + `local`), interpolates variables (`${API_URL}`), and routes them to specific monorepo targets.
  </Card>
  <Card title="AI Safety" icon="approve-check">
    Standard tools assume a human operator. Hush assumes an AI assistant. `hush set` and `hush inspect` allow AI agents to manage secrets **without ever seeing the plaintext values**.
  </Card>
  <Card title="Cross-Platform" icon="laptop">
    Works on macOS, Linux, and Windows. Handles shell differences and provides native GUI prompts for secret entry when running in non-interactive modes (like AI agent sessions).
  </Card>
  <Card title="Encrypted at Rest" icon="lock-closed">
    Secrets stay encrypted on disk. `hush run` decrypts to memory only. No plaintext `.env` files for AI to accidentally read.
  </Card>
</CardGrid>

## Quick Example

```bash
# Initialize configuration
npx hush init

# Encrypt your .env files  
npx hush encrypt

# Run with secrets (decrypts to memory only!)
npx hush run -- npm start

# Run with production secrets
npx hush run -e production -- npm build

# Add a secret interactively (AI-safe)
npx hush set DATABASE_URL

# Push to Cloudflare Workers
npx hush push
```

## The Problem

AI coding assistants are incredibly helpful, but they can accidentally expose your secrets:

- Even with instructions to "not read .env files", LLMs find creative ways using `cat`, `grep`, or shell tricks
- Traditional secrets management leaves plaintext files on disk—easy targets for accidental exposure
- In monorepos, different packages need different subsets of environment variables

## The Solution

Hush keeps secrets **encrypted at rest**—there are no plaintext `.env` files to read:

- **`hush run -- <command>`** decrypts secrets to memory and runs your command
- **`hush set <KEY>`** lets AI help add secrets without seeing the values
- Monorepo-aware routing sends `NEXT_PUBLIC_*` to frontend, server secrets to API

```yaml
# hush.yaml
sources:
  shared: .env
  development: .env.development
  production: .env.production

targets:
  - name: app
    path: ./app
    format: dotenv
    include:
      - EXPO_PUBLIC_*

  - name: api
    path: ./api
    format: wrangler
    exclude:
      - EXPO_PUBLIC_*
```

One command. All packages. Correct secrets.
